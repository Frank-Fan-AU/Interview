## 什么是状态
- 组件内部状态（useState,useReducer）
- 跨组件共享状态

## 为何需要管理
避免Prop Drilling （属性逐层传递）
提升应用可维护性，可预测性
集中化数据逻辑

## react内置方案
useState, useReducer, Context API

## 状态管理选型关键考量因素

- 项目规模和复杂度
- 性能要求
- 生态和社区的支持
- 异步数据流管理，DevTools调试体验，持久化，中间件

# Context API
React内置，无需额外哭
使用场景：
    - 中小型应用，全局状态数量有限
    - 主题切换，用户认证信息等
优点：
    - 简单易上手，API直观
    - 官方支持，与React生态结合紧密
缺点：
    性能问题，Context值变化所有消费了他的组件都会重新渲染，消费组件很多很复杂的话就会有性能瓶颈
    如果真要用在复杂项目，可能需要把大context拆成小context，大组件往小拆，用usememo等优化


# Redux(Redux Toolkit)
强大可预测的状态容器，遵循flux架构（单一数据流）

使用场景：
    - 多人写作，他的严格数据流能带来很多好处

有点：
    -强大的DevTools，庞大的生态，中间件丰富（saga， thunk）

样板代码较多，备受诟病，Redux Toolkit(RTK)大幅简化样式代码，但即使这样，对于一些简单场景来讲还是有点重

学习曲线相对轻量级方案还是有点陡峭

# Zustand
基于Hooks的轻量级、简洁的状态管理

使用场景： 从小型项目到大型项目均可，追求简洁高效

优点： 
    - API极其简单，上手快，样板代码少
    - 灵活，不强制特定目录结构
    - 对异步操作友好，性能表现良好

    允许组件只订阅store中他们实际需要的部分，避免了不必要的渲染

缺点：
    - 生态相对Redux相对较小
    - DevTools体验不如Redux


# 面试时该如何表达？
取决于项目实际情况
结合项目经验：
    - 描述过去项目中遇到的状态管理痛点
    - 解释为何选择了特定方案（基于考量因素）
    - 该方案带来的好处和遇到的挑战
展现权衡能力：
    对比不同方案的优劣
    如果可以重来，是否会做不同选择，为什么？

简单来说就是
context api轻量便捷
redux toolkit成熟强大
zustand简洁高效

